# 05. 설계 원칙: SOLID
- 단일 책임 원칙 (SRP)
- 개방-폐쇄 원칙 (OCP)
- 리스코프 치환 원칙 (LSP)
- 인터페이스 분리 원칙 (ISP)
- 의존 역전 원칙 (DIP)

## 1. 단일 책임 원칙 (SRP)
- 클래스는 단 한 개의 책임을 가져야 한다.

### 1.1 단일 책임 원칙 위반이 불러오는 문제점
- 책임의 개수가 많아질수록 한 책임의 기능 변화가 다른 책임에 주는 영향은 비례해서 증가한다. 결국, 코드를 절차 지향적으로 만들어 버린다.
- 재사용을 어렵게 한다.

### 1.2 책임이란 변화에 대한 것
- 책임의 단위는 변화되는 부분과 관련이 있다.
- 단일 책임 원칙을 지키는지 확인할 때는 사용자를 확인해 본다.
  - 클래스의 사용자들이 서로 다른 메소드들을 사용한다면 그들 메소드는 각각 다른 책임에 속할 가능성이 높다.

## 2. 개방 폐쇄 원칙 (OCP)
- 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
  - 기능을 변경하거나 확장할 수 있으면서 그 기능을 사용하는 코드를 수정하지 않는다.
- 확장되는 부분(즉, 변화되는 부분)을 추상화해서 표현해야 한다.
- 또는, 상속을 이용해야 한다.
  - 하위 클래스에서 오버라이딩.

### 2.1 개방 폐쇄 원칙이 깨질 때의 주요 증상
- 다운 캐스팅을 한다.
  - instanceof와 같은 타입 확인 연산자를 사용한다면 해당 코드는 개방 폐쇄 원칙을 지키지 않을 가능성이 높다.
- 비슷한 if~else 블록이 존재한다.

### 2.2 개방 폐쇄 원칙은 유연함에 대한 것
- 기존 코드를 수정해 주어야 한다면, 새로운 기능을 추가하는 것이 점점 힘들어진다. (= 확장에는 닫히고, 변경에는 열리는 것)
- 변화와 관련된 구현을 추상화하는 습관을 갖자.

## 3. 리스코프 치환 원칙 (LSP)
- 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

### 3.1 리스코프 치환 원칙을 지키지 않을 때의 문제
- 직사각형-정사각형 문제.
- 상위 타입에서 지정한 리턴 값의 범위에 해당되지 않는 값을 리턴.

### 3.2 리스코프 치환 원칙은 계약과 확장에 관한 것
- 리스코프 치환 원칙은 기능의 명세에 대한 내용이다.
- 기능 실행의 계약과 관련해서 흔히 발생하는 위반 사례
  - 명시된 명세에서 벗어난 값을 리턴한다.
  - 명시된 명세에서 벗어난 익셉션을 발생한다.
  - 명시된 명세에서 벗어난 기능을 수행한다.
- 리스코프 치환 원칙은 확장에 대한 것이다.
- 리스코프 치환 원칙을 어기면 개방 폐쇄 원칙을 어길 가능성이 높아진다.
  - instanceof를 사용하면 리스코프 치환 원칙을 위반할 때 발생하는 증상이다.

## 4. 인터페이스 분리 (ISP)
- 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

### 4.1 인터페이스 변경과 그 영향

### 4.2 인터페이스 분리 원칙
- 자신이 사용하는 메소드에만 의존해야 한다.
- 인터페이스 분리 원칙은 인터페이스와 콘크리트 클래스의 재사용성을 높여 주는 효과도 갖는다.

### 4.3 인터페이스 분리 원칙은 클라이언트에 대한 것
- 클라이언트가 인터페이스에 영향을 미칠 수 있지만, 인터페이스가 클라이언트에 영향을 미치면 안 된다.

## 5. 의존 역전 법칙 (DIP)
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
- 고수준 모듈 -> 어떤 의미 있는 단일 기능을 제공하는 모듈.
- 저수준 모듈 -> 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현

### 5.1 고수준 모듈이 저수준 모듈에 의존할 때의 문제
- 프로그램의 변경을 어렵게 만든다.

### 5.2 의존 역전 원칙을 통한 변경의 유연함 확보
- 추상화를 이용하여 저수준 모듈이 고수준 모듈을 의존하게 만들어야 한다.

### 5.3 소스 코드 의존과 런타임 의존
- 초기에 FilowController 클래스는 FileDataReader에 직접적으로 의존하였으나, 추상 타입 ByteSource에 의존하도록 바뀌었다.
- ByteSource 인터페이스는 저수준 모듈보다는 고수준 모듈은 FlowController 입장에서 만들어지는데, 이것은 고수준 모듈이 저수준 모듈에 의존했던 상황이 역전되어 저수준 모듈이 고수준 모듈에 의존하게 된다는 것을 의미한다.
- 소스 코드 상에서의 의존은 역전되었지만 런타임에서의 의존은 고수준 모듈의 객체에서 저수준 모듈의 객체로 향한다.

### 5.4 의존 역전 원칙과 패키지
- 의존 역전 원칙은 타입의 소유도 역전시킨다.
- 타입의 소유 역전은 각 패키지를 독립적으로 배포할 수 있도록 만들어 준다.
