# 06. DI(Dependency Injection)와 서비스 로케이터
## 1. 어플리케이션 영역과 메인 영역
- 모든 의존은 메인 영역에서 어플리케이션 영역으로 향한다.
- 즉, 어플리케이션 영역에서 메인 영역으로의 의존은 존재하지 않으므로 메인 영역을 변경한다고 해도 어플리케이션 영역은 변하지 않는다.
- 서비스 로케이터 -> 사용할 객체를 제공하는 책임을 갖는 객체.
  - 예를 들어, A 클래스는 JobQueue 객체를 사용하고 싶고, B 클래스는 Transcoder 객체를 사용하고 싶다고 하자.
  - 이때, Locater 클래스 안의 JobQueue와 Transcoder 객체를 초기화한 뒤 A와 B 클래스에 원하는 객체를 제공할 수 있다.
  - 몇 가지 단점이 존재함.

## 2. DI(Dependency Injection)을 이용한 의존 객체 사용
```java
public class Worker {
  public void run() {
    JobQueue jobQueue = new FileJobQueue(); // DIP 위반
  }
}
```
- 위와 같이 콘크리트 클래스를 직접 사용해서 객체를 생성하게 되면 의존 역전 원칙은 위반하게 된다.
- 또한, 서비스 로케이터는 단점이 있으므로 DI를 통해 의존성을 주입할 수 있다.
- 생성자를 이용한 의존 객체 주입한다.
- 객체 조립 역할을 수행하는 클래스를 별도로 분리한다.
- 스프링 프레임워크는 객체를 생성하고 조립해 주는 기능을 제공하는 DI 프레임워크이다.

### 2.1 생성자 방식과 메소드 방식
- DI를 적용하려면 의존하는 객체를 전달받을 수 있는 방법을 제공해야하는데, 두 가지 방식이 있다.
  - 생성자 방식
    - 생성자를 통해 전달받은 객체를 필드에 보관한 뒤, 메소드에서 사용한다.
  - 설정 메소드 방식
    - 특정 메소드의 파라미터로 전달받은 의존 객체를 필드에 보관하며, 다른 메소드에서는 필드를 사용해서 의존 객체의 기능을 실행한다.
    - setXXX()
- 각 방식의 장단점
  - 생성자 방식
    - 생성자를 통해서 의존 객체를 전달받기 때문에, 객체를 생성하는 시점에서 의존 객체가 정상인지 확인할 수 있다.
    - 의존 객체를 먼저 생성할 수 없다면 생성자 방식을 사용할 수 없게 된다.
  - 설정 메소드 방식
    - 객체를 생성한 뒤에 의존 객체를 주입하게 되므로 의존 객체를 설정하지 못한 상태에서 객체를 사용하게 될 수 있다. 이때, 널포인터 익셉션이 발생할 수 있다.
    - 어떠한 이유로 인해 의존할 객체가 나중에 생성된다면 이 방식을 사용하는 것이 좋다.
    - 의존할 객체가 많을 경우, 생성자 방식에 비해 어떤 의존 객체가 설정되는지 표현할 수 있어서 코드의 가독성을 높여 준다.

### 2.2 DI와 테스트
- DI는 의존 객체를 Mock 객체로 쉽게 대체할 수 있도록 함으로써 단위 테스트를 할 수 있도록 돕는다.
- 생성자나 설정 메소드를 이용해서 Mock 객체를 쉽게 전달할 수 있다.

### 2.3 스프링 프레임워크 예
- 스프링 프레임워크는 생성자 방식과 설정 메소드 방식을 모두 지원한다.

## 3. 서비스 로케이터를 이용한 의존 객체 사용
