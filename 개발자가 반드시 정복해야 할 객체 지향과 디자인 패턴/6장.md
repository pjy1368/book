# 06. DI(Dependency Injection)와 서비스 로케이터
## 1. 어플리케이션 영역과 메인 영역
- 모든 의존은 메인 영역에서 어플리케이션 영역으로 향한다.
- 즉, 어플리케이션 영역에서 메인 영역으로의 의존은 존재하지 않으므로 메인 영역을 변경한다고 해도 어플리케이션 영역은 변하지 않는다.
- 서비스 로케이터 -> 사용할 객체를 제공하는 책임을 갖는 객체.
  - 예를 들어, A 클래스는 JobQueue 객체를 사용하고 싶고, B 클래스는 Transcoder 객체를 사용하고 싶다고 하자.
  - 이때, Locater 클래스 안의 JobQueue와 Transcoder 객체를 초기화한 뒤 A와 B 클래스에 원하는 객체를 제공할 수 있다.
  - 몇 가지 단점이 존재함.

## 2. DI(Dependency Injection)을 이용한 의존 객체 사용
```java
public class Worker {
  public void run() {
    JobQueue jobQueue = new FileJobQueue(); // DIP 위반
  }
}
```
- 위와 같이 콘크리트 클래스를 직접 사용해서 객체를 생성하게 되면 의존 역전 원칙은 위반하게 된다.
- 또한, 서비스 로케이터는 단점이 있으므로 DI를 통해 의존성을 주입할 수 있다.
- 생성자를 이용한 의존 객체 주입한다.
- 객체 조립 역할을 수행하는 클래스를 별도로 분리한다.
- 스프링 프레임워크는 객체를 생성하고 조립해 주는 기능을 제공하는 DI 프레임워크이다.

### 2.1 생성자 방식과 메소드 방식
- DI를 적용하려면 의존하는 객체를 전달받을 수 있는 방법을 제공해야하는데, 두 가지 방식이 있다.
  - 생성자 방식
    - 생성자를 통해 전달받은 객체를 필드에 보관한 뒤, 메소드에서 사용한다.
  - 설정 메소드 방식
    - 특정 메소드의 파라미터로 전달받은 의존 객체를 필드에 보관하며, 다른 메소드에서는 필드를 사용해서 의존 객체의 기능을 실행한다.
    - setXXX()
- 각 방식의 장단점
  - 생성자 방식
    - 생성자를 통해서 의존 객체를 전달받기 때문에, 객체를 생성하는 시점에서 의존 객체가 정상인지 확인할 수 있다.
    - 의존 객체를 먼저 생성할 수 없다면 생성자 방식을 사용할 수 없게 된다.
  - 설정 메소드 방식
    - 객체를 생성한 뒤에 의존 객체를 주입하게 되므로 의존 객체를 설정하지 못한 상태에서 객체를 사용하게 될 수 있다. 이때, 널포인터 익셉션이 발생할 수 있다.
    - 어떠한 이유로 인해 의존할 객체가 나중에 생성된다면 이 방식을 사용하는 것이 좋다.
    - 의존할 객체가 많을 경우, 생성자 방식에 비해 어떤 의존 객체가 설정되는지 표현할 수 있어서 코드의 가독성을 높여 준다.

### 2.2 DI와 테스트
- DI는 의존 객체를 Mock 객체로 쉽게 대체할 수 있도록 함으로써 단위 테스트를 할 수 있도록 돕는다.
- 생성자나 설정 메소드를 이용해서 Mock 객체를 쉽게 전달할 수 있다.

### 2.3 스프링 프레임워크 예
- 스프링 프레임워크는 생성자 방식과 설정 메소드 방식을 모두 지원한다.

## 3. 서비스 로케이터를 이용한 의존 객체 사용
- 안드로이드 프레임워크는 DI 처리를 위한 방법을 제공하지 않는다.

### 3.1 서비스 로케이터의 구현
- 서비스 로케이터는 어플리케이션에서 필요로 하는 객체를 제공하는 책임을 갖는다.

#### 객체 등록 방식의 서비스 로케이터 구현
- 서비스 로케이터를 생성할 때 사용할 객체를 전달한다.
- 서비스 로케이터 인스턴스를 지정하고 참조하기 위한 static 메소드를 제공한다.
- 고수준 모듈에서 저수준 모듈에 직접 접근하는 것을 유도할 수 있어서 의존 역전 원칙이 위반될 수 있다.

#### 상속을 통한 서비스 로케이터 구현
- 객체를 구하는 추상 메소드를 제공하는 상위 타입 구현
- 상위 타입을 상속받은 하위 타입에서 사용할 객체 설정

#### 제네릭/템플릿을 이용한 서비스 로케이터 구현
- 서비스 로케이터의 단점은 인터페이스 분리 원칙을 위반한다는 점이다.
- 예를 들어, JobCLI 클래스가 사용하는 타입은 JobQueue뿐인데, ServiceLocator를 사용함으로써 Transcoder 타입에 대한 의존이 발생한다.
- 이를 해결하려면 의존 객체마다 서비스 로케이터를 작성해야 하는데, 동일한 구조의 서비스 로케이터 클래스를 중복해서 만들게 된다.
- 따라서, 제네릭이나 템플릿을 이용해서 서비스 로케이터를 구현하면 중복된 코드를 피하면서 인터페이스를 분리할 수 있다.

### 3.2 서비스 로케이터의 단점
- 동일 타입의 객체가 다수 필요할 경우, 각 객체 별로 제공 메소드를 만들어 주어야 한다는 점이다.
- 인터페이스의 분리 원칙을 위배한다.
