## 10장. 병행 처리
### 10.1 병행 처리란?
- 병행 처리 : 복수의 처리를 시간축 상에 오버랩에서 실행하는 것.

### 10.2 잘게 분할해서 실행한다
- 사람의 눈으로 보면 프로그램이 계속 동작하는 것처럼 보이지만, 실제로는 잘게 분할해서 실행되고 있다.

### 10.3 처리를 변경하는 2가지 방법
#### 협력적 멀티태스크
- 협력적 멀티태스크 -> 처리가 일단락되는 시점에서 자발적으로 처리 교대를 하는 방법.
- 프로그램 버그로 인해 교대가 되지 않을 수 있음.

#### 선점적 멀티태스크
- 선점적 멀티태스크 -> 일정 시간에 교대하는 방법.

### 10.4 경합 상태 방지법
- 선점적 멀티태스크는 프로그램 사용자 입장에서는 좋은 방법이지만, 프로그래머 입장에서는 언제 교대할지 모르는 상태에서 작동되는 프로그램을 개발하기 어렵다.
- 경합 상태(Race condition) <=> 스레드 세이프(thread safe)가 아니다.
  - 예금 잔고가 10000원이상일 때 10000원을 출금하는 코드가 있다고 하자.
  - 하나의 스레드에서 이를 작동하면 괜찮지만, 선점적 멀티태스크 방식으로 작동하다가 아래와 같은 문제가 발생할 수 있다.
  - (예금 잔고가 15,000원 있다고 하자. 우선 프로그램 A가 실행된다.)
  - A : 예금 잔고가 10,000원이상 있는가? -> Yes (여기서 다른 프로그램 B로 교대한다.)
  - B : 예금 잔고가 10,000원이상 있는가? -> Yes
  - B : 예금 잔고를 10,000원 줄이고 10,000원 출금한다. (예금 잔고는 5,000원이 되고 A로 교대한다.)
  - A : 예금 잔고를 10,000원 줄이고, 10,000원 출금한다. (예금 잔고는 5,000원인데 10,000원을 출금하게 된다.)

#### 경합 상태의 3가지 조건
- 아래의 조건을 모두 만족해야한다.
  - 2가지 처리가 변수를 공유하고 있다.
  - 적어도 하나의 처리가 그 변수를 변경한다.
  - 한쪽 처리가 한 단락 마무리 전에, 다른 한쪽의 처리가 끼어들 가능성이 있다.

#### 공유하지 않는다.
- 프로세스
  - UNIX에서는 실행 중의 프로그램을 프로세스라고 부르는데, 프로세스는 메모리를 공유하지 않는다.
  - 시간이 지나서 결국 메모리를 공유하는 경량 프로세스가 만들어졌다. 이것은 메모리를 공유하지 않는 구조가 너무 엄격하였기 때문이다.
- 액터 모델   
  - 병행해서 동작하는 복수의 처리가 정보를 교환하는 방법. 메모리 공유가 아니라, 메시지를 보낸다로 바꿨다.
  - 비동기 처리.

#### 변경하지 않는다.
- Haskell의 모든 값은 변경 불가능하다.
- C++에서 const를 붙여 변수 선언을 하면, 변경할 수 없는 변수가 된다.
- Scala에서 val로 선언한 것은 변경할 수 없는 변수가 된다.
- Java에서는 Immutable 패턴이 사용된다.
  - 클래스에서 private 필드를 만들어서 getter 메소드는 생성하되, setter 메소드는 금지한다.

#### 끼어들지 않는다.
- 협력적 스레드의 사용
  - 파이버, 코루틴, 그린 스레드
- 끼어들면 곤란해지는 처리에 표식을 붙인다
  - 락, 뮤텍스, 세마포어

### 10.5 락의 문제점과 해결책
#### 락의 문제점
- 교착 상태가 발생한다
  - 공유된 X와 Y를 변경하는 처리 A와 처리 B가 있다고 하자.
  - A는 'X를 락시키고, Y를 락시킨다.'는 순서로 락을 걸어두고, B는 'Y를 락시키고, X를 락시킨다.'는 순서로 락을 걸어둔다.
  - 어떤 시점에서 A가 X를 락하고, B가 Y를 락한 상태에서 서로가 상대방 락이 풀리는 것을 기다리는 문제가 생긴다.
  - 따라서, 프로그래머는 무엇을 락을 걸어야 하는지 뿐만아니라 어떤 순서로 락을 걸어야 하는지도 판단해야 한다.
- 합성할 수 없다
  - 어떤 리스트 X에서 선두값을 꺼내어 그것을 다른 리스트에 Y에 추가하는 처리를 생각해 보자.
  - X에서 선두값을 꺼내고 난 뒤, 그 값을 넣기 전까지 어중간한 상태에서 다른 명령이 끼어들 수 있다.
  - 따라서 프로그래머가 별도로 락 상단에서 락을 또 걸어야 한다.

#### 트랜잭션 메모리
- 실험적으로 해보고, 실패하면 처음부터 다시 고쳐서 하고, 성공하면 변경을 공유한다.
- 쓰는 처리의 빈도가 높을 때는 '다시 고쳐서 하기'작업이 많아져서 성능이 나빠진다.
