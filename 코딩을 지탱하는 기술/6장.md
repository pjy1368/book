## 6장. 에러 처리
### 6.1 프로그램도 실패를 한다
- 프로그래밍 언어에도 가스 누출 검지기 같은 '실패를 알리는 구조'가 필요하다.

### 6.2 실패를 어떻게 전달할까?
#### 반환값으로 실패를 전달한다.
- ex) 성공하면 0, 실패하면 그 이외의 값 반환.
- 단점 : 실패를 놓칠 수 있다, 에러 처리 때문에 코드를 해석하기 어렵다.

#### 실패를 놓칠 수 있다
- 프로그래머가 반환값 확인을 잊어버렸을 때 실패를 놓치게 된다.

#### 에러 처리때문에 코드를 해석하기 어렵다.
- 3개의 기능을 위해서 9개 이상의 에러 처리 코드가 들어가면 가독성을 해친다.
- 한 곳에 에러 코드 정리를 어떻게 할까?

#### 점프로 에러 처리를 정리한다.
- goto문을 통해 에러 코드를 한 곳에 정리

#### 실패하면 점프한다.
- 점프할 장소를 사전에 등록.

### 6.3 실패할 것 같은 처리를 묶는 구문
- PL/I -> 미리 실패했을 때 처리를 등록해둔 후 실패할 것 같은 코드를 작성.
- Java -> 실패할 것 같은 코드를 미리 try{...}로 묶어둔 후 실패했을 때 처리를 씀.

#### CLU에 도입
```
begin
  % 실패할 것 같은 처리
  % 실패할 것 같은 처리
end except when 실패 종류 :
  % 실패할 것 같은 처리
  % 실패할 것 같은 처리
end
```

#### C++에 도입
```c++
try {
  /* 실패할 것 같은 코드 */
} catch {
  /* 에러 처리 명령 */
}
```
- 그 외에 에러를 발생시키는 throw 용어가 등장함.

#### Windows NT 3.1에 도입
- __try, __except, __finally을 사용함.
- 여기서 finally은 실패해도 성공해도 실행하고 싶은 코드를 작성할 때 사용한다.

### 6.4 출구는 하나다
#### 왜 finally를 도입한 것일까?
- 프로그래머가 예측하지 못한 종료가 발생했을 시 메모리 블록이나 파일 등의 리소스를 잘 닫힐 수 있게 한다.
- 메모리 부족등의 특정 문제에 대해서도 goto 구문이나 반환값 개념을 사용하지 않고 간단한 구조화 코드로 대응할 수 있다.

#### 짝이 되는 처리를 반드시 실행한다.
- ex) 파일 열었다가 닫는 처리, 락을 걸었다가 푸는 처리
- finally를 통해 파일을 닫아주거나 락을 풀 수 있음.

#### Finally가 없는 C++에서의 해결
- RAII(Resource Acquisition Is Initialization) 기술을 사용한다.
- 특정 클래스의 소멸자에서 리소스를 닫도록 함.

#### D언어의 scope(exit)를 사용한 해결
- C++의 RAII를 거부.
```
void abc()
{
  Mutex m = new Mutex;
  
  lock(m); // Mutex를 락한다.
  scope(exit) unlock(m); // 스코프 종료 시에 락을 풀어주라고 등록함.
  
  foo(); // 처리를 실행
}
```

### 6.5 어떤 경우에 예외를 던질까?
- 예외적인 상황이 무엇일까?

#### 함수 호출 시 인수가 부족한 경우
- ex) 인수 두 개를 가진 함수가 인수 한 개만 호출.

#### 배열 범위 밖에 있는 것을 취득하려고 했을 때
- ex) 배열의 사이즈가 3인데, 4번째 요소를 접근하려고 하는 경우.

#### 틀리면 바로 예외를 던진다

### 6.6 예외의 전파
- 예를 들어, f가 g를 호출하고 g가 h를 호출한다고 가정하자.
- h에서 예외가 발생하였는데 처리가 되지 않았다면 g에서 확인하고, g에서도 처리 되지 않았다면 f에서 확인하고, f에서도 확인하였는데 처리 되지 않으면 비정상 종료된다.

#### 예외 전파의 문제점
- f가 호출하는 모든 함수의 소스 코드를 보지 않으면 함수 f가 어떤 예외를 던질 가능성이 있는지 알 수 없다.

#### Java의 검사 예외
- 어떤 예외를 던질 지를 명시적으로 선언하는 것의 필요성이 대두되었다.
- throw를 사용하여 위 목적을 달성할 수 있다.
```java
class Foo {
  // shippai는 MyException을 던진다.
  void shippai() throws MyException {
    throw new MyException();
  }
  
  // shippai를 사용하기 위해서는 'throws MyExceptions'이라 선언하거나
  void foo() throws MyException {
    shippai();
  }
  
  // MyException을 catch해서 에러 처리한다.
  void bar() {
    try {
        shippai();
    } catch (MyException e) {
       ...
    }
  }
}
```

#### 검사 예외가 잘 사용되지 않는 이유
- 한 마디로 말하면, 귀찮다.

### 6.7 정리
- 실패를 전달하는 방법 : '반환값으로 알린다', '실패하면 점프한다'
- 예외 처리의 문제
  - 함수의 출구가 여러 개로써 '짝을 이루는 처리'를 빠르게 짝을 지어 처리하는 것이 어렵다.
  - 함수가 어떤 예외를 던질지 그 함수의 코드를 확인해도 알 수 없다.
- Google 코딩 규약에서는 C++로 예외를 사용하는 것을 금지한다.
